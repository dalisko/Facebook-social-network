# -*- coding: utf-8 -*-
"""graph.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bP3yS9Kq0u7eq-G3PncWDUoHAdVh0NNU
"""

# Commented out IPython magic to ensure Python compatibility.
from google.colab import files
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

from google.colab import drive
drive.mount('/content/drive')


import random
random.seed(500)


# given number of nodes n and probability p, output a random graph 
def create_graph(n,p):
    G = []
    for i in range(n):
        for j in range(i+1,n):
          if (np.random.random() <= p):
            G.append([i,j])
    return([G , n])

# given a graph G and nodes i,j, output the length of the shortest
# path between i and j in G.

#get neighbors of node
def neighbors(G,n):
  nbrs = []
  for [i,j] in G[0]:
    if(i == n):
      nbrs.append(j)
    if (j == n):
      nbrs.append(i)
  return(nbrs)


def shortest_path(G,nbrs,i,j):
  
    #Takes in the Graph, a precomupted list of neighbors for each node, and a
    #start and end node
    #In V: Column 0 is the node, Column 1 is inf for not visited, 1 for visited,
    #2 for has been current, Column 2 is the distance the node is from the
    #start node, Column 3 is the pointer back to the parent node.
    v = np.ones([G[1],4]) * np.inf
    v[:,0] = np.arange(G[1])
    
    current = i
    v[i,3] = i
    
    v[i,1] = 1
    v[i,2] = 0
    
    avail = v[np.where(v[:,1] == 1)]
    
    while (v[j,1] == np.inf and avail.size > 0):
      
      current = int(avail[np.argmin(avail[:,2]),0])
      v[current,1] = 2
      
      for n in nbrs[current]:
        if (v[n,1] == np.inf):
          v[n,1] = 1
          v[n,3] = current
          v[n,2] = v[int(v[n,3]),2] + 1
          
      avail = v[np.where(v[:,1] == 1)]
    
    if v[j,1] == np.inf:
      return [[], v[j,2]]
    
    path = [j]
    c = int(j)
    
    while (int(v[c,3]) != c):
      c = int(v[c,3])
      path.append(c)
      
    return(np.flip(path), v[j,2])

"""### Constructing a graph with $n=1000$ and $p=0.1$ and generating 1000 random pairs of nodes."""

G = create_graph(1000, .1)

#for each node, get its neighbors

nbrs = []

for i in range(1000):
  nbrs.append(neighbors(G,i))

#create 1000 random pairs

pairs = []

while(len(pairs) <= 1000):
  
  i = np.random.randint(1000)
  j = np.random.randint(1000)
  
  if ([i,j] not in pairs and [j,i] not in pairs):
          pairs.append([i,j])

#build average shortest path array which contains start node, end node
#and distance between them

avg_shortest_path = []
for [i,j] in pairs:
  
  p, d = shortest_path(G,nbrs,i,j)
  avg_shortest_path.append([i,j,d])

#calculate average distance
avg_shortest_path = np.array(avg_shortest_path)
np.mean(avg_shortest_path[:,2])


#running shortest path for the four different probability values
n = 1000
lengths1 = []

for p in np.arange(0.01,0.05,0.01):
  G = create_graph(n,p)
  
  nbrs = []
  for i in range(1000):
    nbrs.append(neighbors(G,i))
  
  l = []
  for [i,j] in pairs:
    pa, d = shortest_path(G,nbrs,i,j)
    l.append([i,j,d])
    
  lengths1.append(l)


#calculating the means and plotting the distances
dist = []
p = np.arange(0.01,0.05,0.01)

for i in range(4):
  dist.append(np.mean(np.array(lengths1[i])[:,2]))

plt.title("Varying P between .01 and .04 by .01")
plt.xlabel("P")
plt.ylabel("Avg Distance")  
plt.plot(p,dist, marker = 'o')

vary_p = lengths[0]

vary_p = pd.DataFrame(vary_p, columns = ["start","end","p=.01"])
vary_p['p=0.02'] = np.array(lengths[1])[:,2]
vary_p['p=0.03'] = np.array(lengths[2])[:,2]
vary_p['p=0.04'] = np.array(lengths[3])[:,2]

for i in range(4):
  print(np.mean(np.array(lengths[i])[:,2]))



"""### Using the facebook data instead of a random graph """

facebook_data = pd.read_csv("/content/drive/My Drive/Networks_datasets/facebook_combined.csv", header = None)
facebook_data = facebook_data.to_numpy()

facebook_data = [facebook_data, 4039]

###a) Repeating the same analysis as above

#generating 1000 random pairs
pairs = []
while(len(pairs) <= 1000):
  
  i = np.random.randint(4039)
  j = np.random.randint(4039) 
  
  if ([i,j] not in pairs and [j,i] not in pairs):
          pairs.append([i,j])

#and computing the neighbors list
nbrs = []

for i in range(4039):
  nbrs.append(neighbors(facebook_data,i))

avg_shortest_path = []

for [i,j] in pairs:
  
  p, d = shortest_path(facebook_data,nbrs,i,j)
  avg_shortest_path.append([i,j,d])


avg_shortest_path = np.array(avg_shortest_path)
np.mean(avg_shortest_path[:,2])



"""### Estimating the probability that two nodes are connected """

fb_data = pd.DataFrame(facebook_data[0])
fb_data.columns = ('Node0','Node1')
probs_groupby = fb_data.groupby(['Node0'])['Node1'].count()/4039
p_conn = 2 * probs_groupby.sum()/4039


#Repeat the process for a random graph with p given from above.

G = create_graph(4039, p_conn)

nbrss = []

for i in range(4039):
  nbrss.append(neighbors(G,i))

avg_shortest_path_1 = []

for [i,j] in pairs:
  
  p, d = shortest_path(G,nbrss,i,j)
  avg_shortest_path_1.append([i,j,d])

avg_shortest_path_1 = np.array(avg_shortest_path_1)
np.mean(avg_shortest_path_1[:,2])
